<script>
    "use strict";
    function addEventListeners(peer) {
        peer.addEventListener("connectionstatechange", (_ev) => {
            consolelog("onconnectionstatechange", peer.connectionState);
        });
        peer.addEventListener("icecandidate", (ev) => {
            consolelog("onicecandidate", JSON.stringify(ev.candidate, null, 2));
        });
        peer.addEventListener("icecandidateerror", (ev) => {
            consolelog("onicecandidateerror", JSON.stringify(ev, null, 2));
        });
        peer.addEventListener("iceconnectionstatechange", (_ev) => {
            consolelog("oniceconnectionstatechange", peer.iceConnectionState);
        });
        peer.addEventListener("icegatheringstatechange", (_ev) => {
            consolelog("onicegatheringstatechange", peer.iceGatheringState);
        });
        peer.addEventListener("negotiationneeded", (_ev) => {
            consolelog("onnegotiationneeded");
        });
        peer.addEventListener("signalingstatechange", (_ev) => {
            consolelog("onsignalingstatechange", peer.signalingState);
            const senders = peer.getSenders();
            for (const sender of senders) {
                if (sender.track != null && sender.track.kind === "video") {
                    console.log(sender.getParameters().codecs);
                }
            }
            const transceivers = peer.getTransceivers();
            transceivers.forEach((transceiver) => {
                if (transceiver.sender.track == null) {
                    return;
                }
                const kind = transceiver.sender.track.kind;
                const sendCodecs = RTCRtpSender.getCapabilities(kind).codecs;
                const recvCodecs = RTCRtpReceiver.getCapabilities(kind).codecs;
                consolelog({ sendCodecs, recvCodecs });
                // if (kind === "video") {
                //     const codecPreferences = []
                //     for (const codec of sendCodecs) {
                //         if (codec.mimeType === "video/VP8") {
                //             codecPreferences.push(codec);
                //         }
                //     }
                //     transceiver.setCodecPreferences(codecPreferences);
                // }
            });
        });
        peer.addEventListener("track", async (ev) => {
            consolelog("ontrack", ev);
        });
    }

    async function captureDesktop() {
        const localStream = await navigator.mediaDevices.getDisplayMedia({
            video: {
                frameRate: 15,
                displaySurface: "monitor",
            },
        });
        consolelog("make Offer");
        const peer = new RTCPeerConnection({ iceServers: [] });
        addEventListeners(peer);
        consolelog("Adding local stream...");
        peer.addStream(localStream);
        await new Promise((resolve) => {
            peer.onnegotiationneeded = () => resolve();
        });
        const localDescription = await peer.createOffer();
        consolelog("createOffer() succsess in promise");
        await peer.setLocalDescription(localDescription);
        consolelog("setLocalDescription() succsess in promise");
        await new Promise((resolve) => {
            peer.onicecandidate = (ev) => {
                if (ev.candidate != null) {
                    // Trickle ICE の場合は、ICE candidateを相手に送る
                    // Vanilla ICE の場合には、何もしない
                } else {
                    // Trickle ICE の場合は、何もしない
                    // Vanilla ICE の場合には、ICE candidateを含んだSDPを相手に送る
                    resolve();
                }
            };
        });
        const localSdpText = peer.localDescription.sdp
        consolelog("---sending sdp ---");
        // consolelog(localSdpText);
        const textarea = document.createElement("textarea");
        textarea.value = localSdpText;
        textarea.readonly = true;
        textarea.onclick = async () => {
            textarea.focus();
            textarea.select();
            await navigator.clipboard.writeText(localSdpText);
        };
        document.body.appendChild(textarea);
        const textarea2 = document.createElement("textarea");
        textarea2.placeholder = "paste remote sdp here";
        textarea2.onclick = async () => {
            textarea2.value = await navigator.clipboard.readText();
            textarea2.focus();
            textarea2.select();
        };
        document.body.appendChild(textarea2);
        const button = document.createElement("button");
        button.appendChild(document.createTextNode("Receive Offer"));
        document.body.appendChild(button);
        await new Promise((resolve) => { button.onclick = resolve; });
        let remoteSdpText = textarea2.value;
        if (remoteSdpText.slice(-1) !== "\n") {
            remoteSdpText += "\n";
        }
        consolelog("Received answer text...");
        // consolelog(remoteSdpText);
        document.body.removeChild(button);
        document.body.removeChild(textarea);
        document.body.removeChild(textarea2);
        const answerSdp = new RTCSessionDescription({
            type: "answer",
            sdp: remoteSdpText,
        });
        await peer.setRemoteDescription(answerSdp);
        consolelog("setRemoteDescription(answer) succsess in promise");
        await new Promise((resolve) => {
            peer.onconnectionstatechange = () => {
                if (peer.connectionState === "disconnected") {
                    resolve();
                }
            };
        });
        consolelog("Hang up.");
        peer.close();
    }


    async function receiveDesktop() {
        const textarea = document.createElement("textarea");
        textarea.placeholder = "paste remote sdp here";
        textarea.onclick = async () => {
            textarea.value = await navigator.clipboard.readText();
            textarea.focus();
            textarea.select();
        };
        document.body.appendChild(textarea);
        const button = document.createElement("button");
        button.appendChild(document.createTextNode("Receive Offer"));
        document.body.appendChild(button);
        await new Promise((resolve) => { button.onclick = resolve; });
        let remoteSdpText = textarea.value;
        if (remoteSdpText.slice(-1) !== "\n") {
            remoteSdpText += "\n";
        }
        consolelog("Received offer text...");
        // consolelog(remoteSdpText);
        document.body.removeChild(textarea);
        document.body.removeChild(button);
        const offerSdp = new RTCSessionDescription({
            type: "offer",
            sdp: remoteSdpText,
        });
        const peer = new RTCPeerConnection({ iceServers: [] });
        addEventListeners(peer);
        const video = document.createElement("video");
        peer.ontrack = (ev) => {
            const remoteStream = ev.streams[0];
            video.muted = true;
            video.volume = 0;
            video.autoplay = true;
            video.playsinline = true;
            video.controls = false;
            video.srcObject = remoteStream;
        };
        await peer.setRemoteDescription(offerSdp);
        consolelog("setRemoteDescription(offer) succsess in promise");
        consolelog("sending Answer. Creating remote session description...");
        const localDescription = await peer.createAnswer();
        consolelog("createAnswer() succsess in promise");
        await peer.setLocalDescription(localDescription);
        consolelog("setLocalDescription() succsess in promise");
        // -- Trickle ICE の場合は、初期SDPを相手に送る -- 
        // -- Vanilla ICE の場合には、まだSDPは送らない --
        //sendSdp(peerConnection.localDescription);
        await new Promise((resolve) => {
            peer.onicecandidate = (ev) => {
                if (ev.candidate != null) {
                    // Trickle ICE の場合は、ICE candidateを相手に送る
                    // Vanilla ICE の場合には、何もしない
                } else {
                    // Trickle ICE の場合は、何もしない
                    // Vanilla ICE の場合には、ICE candidateを含んだSDPを相手に送る
                    resolve();
                }
            };
        });
        const localSdpText = peer.localDescription.sdp;
        consolelog("---sending sdp ---");
        // consolelog(localSdpText);
        const textarea2 = document.createElement("textarea");
        textarea2.value = localSdpText;
        textarea2.readonly = true;
        textarea2.onclick = async () => {
            textarea2.focus();
            textarea2.select();
            await navigator.clipboard.writeText(localSdpText);
        };
        document.body.appendChild(textarea2);
        await new Promise((resolve) => {
            peer.onconnectionstatechange = () => {
                if (peer.connectionState === "connected") {
                    resolve();
                }
            };
        });
        document.body.removeChild(textarea2);
        document.body.appendChild(video);
        video.play();
        await new Promise((resolve) => {
            peer.onconnectionstatechange = () => {
                if (peer.connectionState === "disconnected") {
                    resolve();
                }
            };
        });
        consolelog("Hang up.");
        peer.close();
        video.pause();
        video.srcObject = null;
        document.body.removeChild(video);
    }


    const logarea = document.createElement("textarea");
    function consolelog(...args) {
        console.log(...args);
        logarea.appendChild(document.createTextNode(args.join(" ") + "\n"));
    }
    window.onerror = (message, source, lineno, colno, error) => {
        consolelog(message, source, lineno, colno, error);
    };
    window.addEventListener("unhandledrejection", (ev) => {
        consolelog(["onUnhandledrejection", ev.reason.stack].join("\n--------\n"));
    });
    document.addEventListener("DOMContentLoaded", (ev) => {
        logarea.style = "display: block; width: 100%; height: 200px;";
        logarea.readonly = true;
        // logarea.onclick = async () => {
        //     logarea.focus();
        //     logarea.select();
        //     await navigator.clipboard.writeText(logarea.value);
        // };
        document.body.appendChild(logarea);
        const button1 = document.createElement("button");
        const button2 = document.createElement("button");
        button1.appendChild(document.createTextNode("captureDesktop"));
        button2.appendChild(document.createTextNode("receiveDesktop"));
        button1.onclick = () => {
            document.body.removeChild(button1);
            document.body.removeChild(button2);
            captureDesktop();
        };
        button2.onclick = () => {
            document.body.removeChild(button1);
            document.body.removeChild(button2);
            receiveDesktop();
        };
        document.body.appendChild(button1);
        document.body.appendChild(button2);
    });
</script>

<body>
</body>